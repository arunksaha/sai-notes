# Userspace VLAN Switch with SAI  
This is Part 3 of the Experimental SAI Project.

This project extends the userspace VLAN switch by adding a minimalist SAI implementation and a management-plane thread. The dataplane still runs entirely in user space, but now SAI callbacks are wired up so MAC-learn events flow into a vendor-style API surface. The SAI layer is intentionally small: just enough SWITCH and VLAN plumbing to demonstrate learn notifications and control-plane hooks without a full feature matrix.

## Goal and Motivation

Build a fully operational L2 datapath while layering in SAI plumbing: a lightweight `libsai` that exposes SWITCH and VLAN APIs, a management-plane thread that registers for FDB notifications, and the original userspace forwarding pipeline. This highlights how control-plane APIs sit next to packet processing without relying on kernel bridges or ASICs.

## Topology Overview

The switch attaches to N veth interfaces. Each veth acts like a physical port; frames are processed in user space and written to chosen egress ports.

```
             +-----------------------+
             |    Userspace Switch   |
             |                       |
             |  +-----------------+  |
   veth0 --> |  |                 |  | --> veth1
             |  |  Dataplane:     |  |
             |  |    - VLAN check |  |
             |  |    - MAC learn  |  |
   veth2 --> |  |    - L2 fwd     |  | --> veth3
             |  |                 |  |
             |  +-----------------+  |
             +-----------------------+

   Each veth interface acts as a physical port of the virtual switch.

```

## Design of the `userspace_switch` executable

### 1. Dataplane (`src/dataplane/switch_dataplane.cpp`)

Runs in its own thread, binds raw AF_PACKET sockets to the veth interfaces, and processes each frame in sequence:

1. Packet Receive  
2. Parse Header  
3. VLAN Membership Check  
4. MAC Learning  
5. Forwarding Decision  
6. Write to Egress Ports  

### 2. Switch State (`src/state/switch_state.cpp`, `src/state/switch_state.h`)

Central in-memory model for VLAN membership, MAC table, and port PVIDs. Shared by both dataplane and management-plane code via locks.

### 3. Management Plane (`src/mgmtplane/switch_mgmtplane.cpp`)

Runs alongside the dataplane in its own thread, initializes SAI, registers for FDB notifications,
and logs callbacks from the control-plane view.

The management plane uses the SAI APIs to create a VLAN (73) and add 3 ports to it.
It also registers a callback function for SAI MAC learning events.

### 4. SAI Shim (`libsai/`)

The project contains a minimalist SAI implementation. 

The APIs demonstrated are the following

 - Switch API: `create_switch`

 - VLAN API: (a) `create_vlan`, and (b) `create_vlan_member`

 - Callback: `sai_fdb_event_notification_fn`

> Author's note: I was halfway in implementing a different design where the SAI library is loaded into a separate (CLI-like) process, and connects to the switch using a GRPC channel.
> However, to keep things simple and focus on the main ideas, I discarded that path and chose to pursue the simplistic approach as captured in this document.


## Directory Structure

```
.
├── build.sh
│       Build helper script that configures and compiles the entire project
│       using CMake. Produces the userspace_switch executable.
│
├── hostinfo.csv
│       Generated by tools/setup.sh. Lists host namespaces, interfaces,
│       IPs, and MACs for the test topology.
│
├── libsai
│   ├── libsai.cpp / libsai.h / libsai_oid.h
│   │       Implements SAI SWITCH/VLAN entry points and FDB event delivery.
│   │
│   └── inc
│           Header stubs for SAI types, status codes, and APIs consumed
│           by the management plane.
│
├── src
│   ├── switch_config.h
│   │       Generated constants (e.g., NumSwitchPorts) written by setup.sh.
│   │
│   ├── dataplane/switch_dataplane.cpp
│   │       Ingress, learning, forwarding, and egress logic using AF_PACKET.
│   │
│   ├── mgmtplane/switch_mgmtplane.cpp
│   │       Initializes SAI, registers FDB callbacks, and logs events.
│   │
│   ├── state/switch_state.cpp
│   │       MAC table, VLAN membership, port PVID handling shared by threads.
│   │
│   ├── state/switch_state.h
│   │       Declarations for switch state structures and APIs.
│   │
│   └── switch_main.cpp
│           Entry point that launches dataplane and management-plane threads.
│
└── tools
    ├── install_deps.sh
    │       Installs system dependencies (cmake, protobuf/grpc toolchain, etc.).
    │
    └── setup.sh
            Creates veth pairs and namespaces, writes switch_config.h, and
            produces hostinfo.csv for the lab topology.
```

## Running the Userspace Switch

### 1. Install Dependencies

```
tools/install_deps.sh
```

### 2. Build the userspace switch

```
$ ./build.sh
```

If the build is successful, then the executable will be available at:
```
build/src/userspace_switch
```

### 3. Create veth Interfaces and Namespaces

[Optional] Cleanup any existing topology:
```
$ sudo bash tools/setup.sh clean
```

Create 4 veth pairs and host namespaces:
```
$ sudo bash tools/setup.sh 
```

This writes `hostinfo.csv` with the virtual host details.

### 4. Run the switch

```
$ sudo build/src/userspace_switch
```

## Verification

In first terminal, run `tcpdump` on an egress port (example: `sudo tcpdump -i veth1`).

In second terminal, run the switch
```
$ sudo build/src/userspace_switch 
[MAIN] Starting uswitch...
[MGMT] Initializing SAI...
[MGMT] SWITCH API ready
[MGMT] VLAN API ready
[MGMT] Switch created, switch_id = 6b8b4567327b23c6
[MGMT] VLAN 73 created, vlan_object_id = 3000000000049
[MGMT] VLAN member added: port 0 -> vlan 73, member_oid = 2000000000000
[MGMT] VLAN member added: port 1 -> vlan 73, member_oid = 2000000000001
[MGMT] VLAN member added: port 3 -> vlan 73, member_oid = 2000000000003
[MGMT] Initialization complete
[DP] port=0 bound to veth0
[DP] port=1 bound to veth1
[DP] port=2 bound to veth2
[DP] port=3 bound to veth3

```

### Sample output

The following is a sample virtual host information after running `setup.sh`.
It shows the IP addresses and MAC addresses of all the virtual hosts.
```
# dell; Mon Dec  8 01:34:02 PM PST 2025
h0,veth0p,10.73.0.1,9e:ad:29:60:fa:90
h1,veth1p,10.73.0.2,82:f7:fb:b4:b4:6e
h2,veth2p,10.73.0.3,de:aa:9e:1c:d8:3a
h3,veth3p,10.73.0.4,3e:80:35:9c:73:0a
```

Sample `ping` output.
```
$ sudo ip netns exec h0 ping -c 2 10.73.0.2
PING 10.73.0.2 (10.73.0.2) 56(84) bytes of data.
64 bytes from 10.73.0.2: icmp_seq=1 ttl=64 time=1.49 ms
64 bytes from 10.73.0.2: icmp_seq=2 ttl=64 time=0.486 ms

--- 10.73.0.2 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1001ms
rtt min/avg/max/mdev = 0.486/0.988/1.490/0.502 ms
```

Following is the console putput at the terminal running the switch right after the `ping`.
```
[Rx] port = 0, dmac = ff:ff:ff:ff:ff:ff, smac = 9e:ad:29:60:fa:90, ethtype = 0x0806
 +LEARN vlan = 73, mac = 9e:ad:29:60:fa:90 at port = 0
  [Tx] port = 1, dmac = ff:ff:ff:ff:ff:ff, smac = 9e:ad:29:60:fa:90, ethtype = 0x0806
  [Tx] port = 3, dmac = ff:ff:ff:ff:ff:ff, smac = 9e:ad:29:60:fa:90, ethtype = 0x0806
== Current FDB ==
vlan=73 mac=9e:ad:29:60:fa:90 port=0


[Rx] port = 1, dmac = 9e:ad:29:60:fa:90, smac = 82:f7:fb:b4:b4:6e, ethtype = 0x0806
 +LEARN vlan = 73, mac = 82:f7:fb:b4:b4:6e at port = 1
  [Tx] port = 0, dmac = 9e:ad:29:60:fa:90, smac = 82:f7:fb:b4:b4:6e, ethtype = 0x0806
== Current FDB ==
vlan=73 mac=82:f7:fb:b4:b4:6e port=1
vlan=73 mac=9e:ad:29:60:fa:90 port=0

[MGMT] FDB event callback, count=1
  [0] event=LEARNED mac=9e:ad:29:60:fa:90 bv_id=3000000000049 switch=0 attrs=2
  [Tx] port = 1, dmac = 82:f7:fb:b4:b4:6e, smac = 9e:ad:29:60:fa:90, ethtype = 0x0800

[MGMT] FDB event callback, count=1
  [0] event=LEARNED mac=9e:ad:29:60:fa:90 bv_id=3000000000049 switch=0 attrs=2
  [Tx] port = 1, dmac = 82:f7:fb:b4:b4:6e, smac = 9e:ad:29:60:fa:90, ethtype = 0x0800

```
The above output shows receipt (Rx) and transmiission (Tx) of frames, learning events (+LEARN),
and FDB snapshots after processing frames.
 - The first frame is flooded only to the the remaining ports (1 and 3) in the vlan (73).
 - The second frame (response to `h0`) is forwarded correctly only to `h0` at port 0; there was no flooding.
 - The FDB snapshot from DP shows the MACs of `h0` and `h1` are learned in VLAN 73 against their correct ports (0 and 1 respectively).
 - Finally, the captured snippet shows the FDB "LEARNED" event callback invoked in the management plane.

Following is the console output at the terminal running `tcpdump`.
```
13:42:43.206522 ARP, Request who-has 10.73.0.2 tell 10.73.0.1, length 28
13:42:43.206575 ARP, Reply 10.73.0.2 is-at 82:f7:fb:b4:b4:6e (oui Unknown), length 28
13:42:43.207306 IP 10.73.0.1 > 10.73.0.2: ICMP echo request, id 62270, seq 1, length 64
13:42:43.207354 IP 10.73.0.2 > 10.73.0.1: ICMP echo reply, id 62270, seq 1, length 64
13:42:44.207544 IP 10.73.0.1 > 10.73.0.2: ICMP echo request, id 62270, seq 2, length 64
13:42:44.207593 IP 10.73.0.2 > 10.73.0.1: ICMP echo reply, id 62270, seq 2, length 64
```

## FAQ

### What is the following error?

```
$ sudo ip netns exec h0 ping -c 1 10.73.0.2
Cannot open network namespace "h0": No such file or directory
```

This means namespace `h0` does not exist. Please run the setup script `tools/setup.sh`.
