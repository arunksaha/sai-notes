# Userspace VLAN Switch with SAI  
This is Part 3 of the Experimental SAI Project.

This project extends the userspace VLAN switch by adding a minimal SAI implementation and a management-plane thread. The dataplane still runs entirely in user space, but now SAI callbacks are wired up so MAC-learn events flow into a vendor-style API surface.

## Goal and Motivation

Build a fully operational L2 datapath while layering in SAI plumbing: a lightweight `libsai` that exposes SWITCH and VLAN APIs, a management-plane thread that registers for FDB notifications, and the original userspace forwarding pipeline. This highlights how control-plane APIs sit next to packet processing without relying on kernel bridges or ASICs.

## Topology Overview

The switch attaches to N veth interfaces. Each veth acts like a physical port; frames are processed in user space and written to chosen egress ports.

```
             +-----------------------+
             |    Userspace Switch   |
             |                       |
             |  +-----------------+  |
   veth0 --> |  |                 |  | --> veth1
             |  |  Dataplane:     |  |
             |  |    - VLAN check |  |
             |  |    - MAC learn  |  |
   veth2 --> |  |    - L2 fwd     |  | --> veth3
             |  |                 |  |
             |  +-----------------+  |
             +-----------------------+

   Each veth interface acts as a physical port of the virtual switch.

```

## Design of the `userspace_switch` executable

### 1. Dataplane (`src/dataplane/switch_dataplane.cpp`)

Runs in its own thread, binds raw AF_PACKET sockets to the veth interfaces, and processes each frame in sequence:

1. Packet Receive  
2. Parse Header  
3. VLAN Membership Check  
4. MAC Learning  
5. Forwarding Decision  
6. Write to Egress Ports  

### 2. Switch State (`src/state/switch_state.cpp`, `src/state/switch_state.h`)

Central in-memory model for VLAN membership, MAC table, and port PVIDs. Shared by both dataplane and management-plane code via locks.

### 3. Management Plane (`src/mgmtplane/switch_mgmtplane.cpp`)

Runs alongside the dataplane, initializes SAI, registers for FDB notifications, and logs callbacks from the control-plane view.

### 4. SAI Shim (`libsai/`)

Minimal vendor-style SAI implementation exposing SWITCH and VLAN API tables. Provides `sai_inform_mac_learn`, the hook the dataplane triggers on MAC learning, which then surfaces as FDB events to the management plane.

## Directory Structure

```
.
├── build.sh
│       Build helper script that configures and compiles the entire project
│       using CMake. Produces the userspace_switch executable.
│
├── hostinfo.csv
│       Generated by tools/setup.sh. Lists host namespaces, interfaces,
│       IPs, and MACs for the test topology.
│
├── libsai
│   ├── libsai.cpp / libsai.h / libsai_oid.h
│   │       Implements SAI SWITCH/VLAN entry points and FDB event delivery.
│   │
│   └── inc
│           Header stubs for SAI types, status codes, and APIs consumed
│           by the management plane.
│
├── src
│   ├── switch_config.h
│   │       Generated constants (e.g., NumSwitchPorts) written by setup.sh.
│   │
│   ├── dataplane/switch_dataplane.cpp
│   │       Ingress, learning, forwarding, and egress logic using AF_PACKET.
│   │
│   ├── mgmtplane/switch_mgmtplane.cpp
│   │       Initializes SAI, registers FDB callbacks, and logs events.
│   │
│   ├── state/switch_state.cpp
│   │       MAC table, VLAN membership, port PVID handling shared by threads.
│   │
│   ├── state/switch_state.h
│   │       Declarations for switch state structures and APIs.
│   │
│   └── switch_main.cpp
│           Entry point that launches dataplane and management-plane threads.
│
└── tools
    ├── install_deps.sh
    │       Installs system dependencies (cmake, protobuf/grpc toolchain, etc.).
    │
    └── setup.sh
            Creates veth pairs and namespaces, writes switch_config.h, and
            produces hostinfo.csv for the lab topology.
```

## Running the Userspace Switch

### 1. Install Dependencies

```
tools/install_deps.sh
```

### 2. Build the userspace switch

```
$ ./build.sh
```

If the build is successful, then the executable will be available at:
```
build/src/userspace_switch
```

### 3. Create veth Interfaces and Namespaces

[Optional] Cleanup any existing topology:
```
$ sudo bash tools/setup.sh clean
```

Create 4 veth pairs and host namespaces:
```
$ sudo bash tools/setup.sh 
```

This writes `hostinfo.csv` with the virtual host details.

### 4. Run the switch

```
$ sudo build/src/userspace_switch
```

## Verification

In one terminal, run `tcpdump` on an egress port (example: `sudo tcpdump -i veth1`).

In another terminal, ping from h0 to h1:
```
$ sudo ip netns exec h0 ping -c 2 10.73.0.2
```

You should see dataplane Rx/Tx logs and an FDB learn callback from the management plane similar to:
```
[MAIN] Starting uswitch...
[DP] port=0 bound to veth0
...
 +LEARN vlan = 1, mac = be:d3:45:41:83:e4 at port = 0
[MGMT] FDB event callback, count=1
  [0] event=LEARNED mac=be:d3:45:41:83:e4 bv_id=0x100000000000000 switch=0 attrs=2
```

MAC addresses and IPs in `tcpdump`, `ping`, and switch output should match `hostinfo.csv`.

## FAQ

### What is the following error?

```
$ sudo ip netns exec h0 ping -c 1 10.73.0.2
Cannot open network namespace "h0": No such file or directory
```

This means namespace `h0` does not exist. Please run the setup script `tools/setup.sh`.
